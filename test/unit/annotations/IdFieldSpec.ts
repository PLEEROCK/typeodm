import * as chai from "chai";
import {expect} from "chai";
import * as sinon from "sinon";
import {IdField} from "../../../src/decorator/Fields";
import {WrongAnnotationUsageError} from "../../../src/decorator/error/WrongAnnotationUsageError";
import {WrongFieldTypeError} from "../../../src/decorator/error/WrongFieldTypeError";
import {defaultMetadataStorage} from "../../../src/metadata-builder/MetadataStorage";

chai.should();
chai.use(require("sinon-chai"));

describe('IdField Annotation', function() {

    class TestClass {
        someProperty: string;
    }

    // -------------------------------------------------------------------------
    // Specifications
    // -------------------------------------------------------------------------

    it('should throw exception if annotation is set to non-property', function () {
        expect(() => IdField()(null, 'someProperty')).to.throw(WrongAnnotationUsageError);
        expect(() => IdField()(new TestClass(), null)).to.throw(WrongAnnotationUsageError);
    });

    it('should throw exception if type in function is not given or is not correct', sinon.test(function () {
        let object = new TestClass();
        let nullInFunction = (type: any): any => null;
        let somethingInFunction = (type: any) => 'not-number';
        expect(() => IdField(nullInFunction)(object, 'someProperty')).to.throw(WrongFieldTypeError);
        expect(() => IdField(somethingInFunction)(object, 'someProperty')).to.throw(WrongFieldTypeError);
    }));

    it('should add a new field metadata to the metadata storage', sinon.test(function () {
        var addFieldMetadata = this.mock(defaultMetadataStorage).expects('addFieldMetadata');
        let object = new TestClass();

        IdField()(object, 'someProperty');
        addFieldMetadata.should.have.been.calledWithMatch({
            object: object,
            name: undefined,
            isId: true,
            isObjectId: false,
            isArray: false,
            isAutoGenerated: false,
            isCreateDate: false,
            isUpdateDate: false,
            propertyName: 'someProperty'
        });
    }));

    it('should add a new metadata with specific type if type is given', sinon.test(function () {
        var addFieldMetadata = this.mock(defaultMetadataStorage).expects('addFieldMetadata');
        let object = new TestClass();
        let typeInFunction = (type: any) => 'number';

        IdField(typeInFunction)(object, 'someProperty');
        addFieldMetadata.should.have.been.calledWithMatch({
            object: object,
            name: undefined,
            type: typeInFunction,
            isId: true,
            isObjectId: false,
            isArray: false,
            isAutoGenerated: false,
            isCreateDate: false,
            isUpdateDate: false,
            propertyName: 'someProperty'
        });
    }));

    it('should add a new metadata with specific type in the function if its given', sinon.test(function () {
        var addFieldMetadata = this.mock(defaultMetadataStorage).expects('addFieldMetadata');
        let object = new TestClass();
        let typeInFunction = (type: any) => TestClass;

        IdField(typeInFunction)(object, 'someProperty');
        addFieldMetadata.should.have.been.calledWithMatch({
            object: object,
            name: undefined,
            type: typeInFunction,
            isId: true,
            isObjectId: false,
            isArray: false,
            isAutoGenerated: false,
            isCreateDate: false,
            isUpdateDate: false,
            propertyName: 'someProperty'
        });
    }));

});
