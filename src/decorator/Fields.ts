import "reflect-metadata";
import {defaultMetadataStorage} from "../metadata-builder/MetadataStorage";
import {WrongAnnotationUsageError} from "./error/WrongAnnotationUsageError";
import {FieldTypeInFunction} from "../metadata-builder/metadata/FieldMetadata";
import {WrongFieldTypeError} from "./error/WrongFieldTypeError";
import {FieldTypes} from "../metadata-builder/FieldTypes";
import {WrongAutoGeneratedIdFieldTypeError} from "./error/WrongAutoGeneratedIdFieldTypeError";

/**
 * Field annotation is used to mark a specific class property as a document field. Only document fields will be
 * persisted to the database when document is being saved.
 */
export function Field(typeFunction?: FieldTypeInFunction): Function;
export function Field(name?: string, typeFunction?: FieldTypeInFunction): Function;
export function Field(name?: string|FieldTypeInFunction, typeFunction?: FieldTypeInFunction): Function {
    return function (object: Object, propertyName: string) {
        if (name instanceof Function) {
            typeFunction = <FieldTypeInFunction> name;
            name = null;
        }

        if (!object || !propertyName || !object.constructor)
            throw new WrongAnnotationUsageError('Field', 'class property', object);

        // check only if type is given because otherwise we are trying to guess a type here
        if (typeFunction && !FieldTypes.validateTypeInFunction(typeFunction))
            throw new WrongFieldTypeError(typeFunction, object.constructor.name, propertyName);

        // temporary fix for date type. need better implementation
        const type = Reflect.getMetadata('design:type', object, propertyName);
        if (!typeFunction && type && type.name && type.name.toLowerCase() === 'date')
            typeFunction = () => 'date';

        // if type is not given then try to guess it using metadata
        if (!typeFunction)
            typeFunction = () => Reflect.getMetadata('design:type', object, propertyName);

        defaultMetadataStorage.addFieldMetadata({
            object: object,
            name: name ? <string> name : undefined,
            type: typeFunction,
            isId: false,
            isObjectId: false,
            isAutoGenerated: false,
            isCreateDate: false,
            isUpdateDate: false,
            isArray: false,
            propertyName: propertyName
        });
    }
}

/**
 * Same as Field annotation, but used to mark a class properties that contain array data.
 */
export function ArrayField(typeFunction: FieldTypeInFunction): Function;
export function ArrayField(name: string, typeFunction: FieldTypeInFunction): Function;
export function ArrayField(name: string|FieldTypeInFunction, typeFunction?: FieldTypeInFunction): Function {
    return function (object: Object, propertyName: string) {
        if (name instanceof Function) {
            typeFunction = <FieldTypeInFunction> name;
            name = null;
        }

        if (!object || !propertyName || !object.constructor)
            throw new WrongAnnotationUsageError('ArrayField', 'class property', object);

        if (!FieldTypes.validateTypeInFunction(typeFunction))
            throw new WrongFieldTypeError(typeFunction, object.constructor.name, propertyName);

        defaultMetadataStorage.addFieldMetadata({
            object: object,
            name: name ? <string> name : undefined,
            type: typeFunction,
            isId: false,
            isObjectId: false,
            isAutoGenerated: false,
            isCreateDate: false,
            isUpdateDate: false,
            isArray: true,
            propertyName: propertyName
        });
    }
}

/**
 * Class property that should contain a document id must be annotated within this annotation.
 */
export function IdField(typeFunction?: FieldTypeInFunction): Function {
    return function (object: Object, propertyName: string) {

        if (!object || !propertyName || !object.constructor)
            throw new WrongAnnotationUsageError('IdField', 'class property', object);

        // check only if type is given because otherwise we are trying to guess a type here
        if (typeFunction && !FieldTypes.validateTypeInFunction(typeFunction))
            throw new WrongFieldTypeError(typeFunction, object.constructor.name, propertyName);

        // if type is not given then try to guess it using metadata
        if (!typeFunction)
            typeFunction = () => Reflect.getMetadata('design:type', object, propertyName);

        defaultMetadataStorage.addFieldMetadata({
            object: object,
            name: undefined,
            type: typeFunction,
            isId: true,
            isObjectId: false,
            isAutoGenerated: false,
            isCreateDate: false,
            isUpdateDate: false,
            isArray: false,
            propertyName: propertyName
        });
    }
}

/**
 * Class property that should contain a document object id must be annotated within this annotation.
 */
export function ObjectIdField(): Function {
    return function (object: Object, propertyName: string) {

        if (!object || !propertyName || !object.constructor)
            throw new WrongAnnotationUsageError('ObjectIdField', 'class property', object);

        const typeFunction = () => Reflect.getMetadata('design:type', object, propertyName);

        defaultMetadataStorage.addFieldMetadata({
            object: object,
            name: undefined,
            type: typeFunction,
            isId: true,
            isObjectId: true,
            isAutoGenerated: false,
            isCreateDate: false,
            isUpdateDate: false,
            isArray: false,
            propertyName: propertyName
        });
    }
}

/**
 * Class property that should contain a document object id must be annotated within this annotation.
 */
export function ObjectIdStringField(): Function {
    return function (object: Object, propertyName: string) {

        if (!object || !propertyName || !object.constructor)
            throw new WrongAnnotationUsageError('ObjectIdStringField', 'class property', object);

        const typeFunction = () => Reflect.getMetadata('design:type', object, propertyName);

        defaultMetadataStorage.addFieldMetadata({
            object: object,
            name: undefined,
            type: typeFunction,
            isId: true,
            isObjectIdString: true,
            isObjectId: true,
            isAutoGenerated: false,
            isCreateDate: false,
            isUpdateDate: false,
            isArray: false,
            propertyName: propertyName
        });
    }
}

/**
 * Class property that should contain a document id must be annotated within this annotation.
 */
export function GeneratedIdField(typeFunction?: FieldTypeInFunction): Function {
    return function (object: Object, propertyName: string) {

        if (!object || !propertyName || !object.constructor)
            throw new WrongAnnotationUsageError('GeneratedIdField', 'class property', object);

        // check only if type is given because otherwise we are trying to guess a type here
        if (typeFunction && !FieldTypes.validateTypeInFunction(typeFunction))
            throw new WrongFieldTypeError(typeFunction, object.constructor.name, propertyName);

        // if type is not given then try to guess it using metadata
        if (!typeFunction)
            typeFunction = () => Reflect.getMetadata('design:type', object, propertyName);

        // if auto generation set to true then make sure that given type is string, because auto generated value gonna be a string
        let type: Function|string = typeFunction();
        if (type instanceof Function)
            type = (<Function> type).name.toLowerCase();
        if (type !== FieldTypes.STRING)
            throw new WrongAutoGeneratedIdFieldTypeError(object, propertyName, type);

        defaultMetadataStorage.addFieldMetadata({
            object: object,
            name: undefined,
            type: typeFunction,
            isId: true,
            isObjectId: false,
            isAutoGenerated: true,
            isCreateDate: false,
            isUpdateDate: false,
            isArray: false,
            propertyName: propertyName
        });
    }
}

/**
 * For the fields that has this annotation will be generated a date when the document will be saved to the database
 * at first time. Please note that this will work only in the case if repository#persist method is used to save document.
 */
export function CreateDateField(name?: string) {
    return function (object: Object, propertyName: string) {

        if (!object || !propertyName || !object.constructor)
            throw new WrongAnnotationUsageError('CreateDate', 'class property', object);

        defaultMetadataStorage.addFieldMetadata({
            object: object,
            name: name ? <string> name : undefined,
            type: type => 'date',
            isId: false,
            isObjectId: false,
            isAutoGenerated: false,
            isCreateDate: true,
            isUpdateDate: false,
            isArray: false,
            propertyName: propertyName
        });
    }
}

/**
 * For the fields that has this annotation will be generated a date and it will be updated every time document is updated.
 * Please note that "update" will work only in the case if repository#persist method is used to save document.
 */
export function UpdateDateField(name?: string) {
    return function (object: Object, propertyName: string) {

        if (!object || !propertyName || !object.constructor)
            throw new WrongAnnotationUsageError('UpdateDate', 'class property', object);

        defaultMetadataStorage.addFieldMetadata({
            object: object,
            name: name ? <string> name : undefined,
            type: type => 'date',
            isId: false,
            isObjectId: false,
            isAutoGenerated: false,
            isCreateDate: false,
            isUpdateDate: true,
            isArray: false,
            propertyName: propertyName
        });
    }
}